<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" /><!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Intro to streams: control-flow and data-flow in Luau" />
<meta name="author" content="Billy Snikkers" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Stream.luau" />
<meta property="og:description" content="Stream.luau" />
<link rel="canonical" href="https://billysnikkers.net/2024/07/11/Stream-Intro.html" />
<meta property="og:url" content="https://billysnikkers.net/2024/07/11/Stream-Intro.html" />
<meta property="og:site_name" content="Billy Snikkers" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-07-11T00:00:00+10:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Intro to streams: control-flow and data-flow in Luau" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Billy Snikkers"},"dateModified":"2024-07-11T00:00:00+10:00","datePublished":"2024-07-11T00:00:00+10:00","description":"Stream.luau","headline":"Intro to streams: control-flow and data-flow in Luau","mainEntityOfPage":{"@type":"WebPage","@id":"https://billysnikkers.net/2024/07/11/Stream-Intro.html"},"url":"https://billysnikkers.net/2024/07/11/Stream-Intro.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/main.css" />
  <link rel="shortcut icon" type="image/x-icon" href="./favicon.ico?" />
  <link rel="stylesheet" href="/assets/css/agate.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-light.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
  <script src="https://unpkg.com/highlightjs-luau/dist/luau.min.js"></script>
  <script>
    hljs.highlightAll();
  </script>
  
<!-- 
  <script>
    hljs.registerLanguage('luau', window.hljsDefineLuau);
    hljs.highlightAll();
  </script> --><link type="application/atom+xml" rel="alternate" href="https://billysnikkers.net/feed.xml" title="Billy Snikkers" /></head><body>

        <nav class="site-nav">
      <input type="checkbox" id="nav-trigger" class="nav-trigger" />
      <label for="nav-trigger">
        <span class="menu-icon">
          <svg viewBox="0 0 18 15" width="18px" height="15px">
            <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
          </svg>
        </span>
      </label>

      <div class="trigger"><a class="page-link" href="/">Home</a><a class="page-link" href="/models">Notes</a></div>
    </nav>
    <main class="page-content" aria-label="Content">
        <div class="wrapper">
            <article
  class="post h-entry"
  itemscope
  itemtype="http://schema.org/BlogPosting"
>
  <head>
    <title>Intro to streams: control-flow and data-flow in Luau</title>
  </head>
  <header class="post-header">
    <div class="post-back">
      <a class="black-link" href="https://billysnikkers.net">
        ← Home
      </a>
    </div>

    <h1 class="post-title p-name" itemprop="name headline">
      Intro to streams: control-flow and data-flow in Luau
    </h1>
    <p class="post-meta">
      <time
        class="dt-published"
        datetime="2024-07-11T00:00:00+10:00"
        itemprop="datePublished"
      >
        Posted:&nbsp;Jul 11, 2024
      </time>
      <time
        class="dt-published"
        datetime="2024-07-11T00:00:00+10:00"
        itemprop="dateUpdated"
      ><br/>Last updated:&nbsp;Jul 11, 2024
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><a href="https://gist.github.com/blinkybool/1390d53a730493e2ce72549c5bf7eaec">Stream.luau</a></p>
<style type="text/css">
  /* .gist {width:500px !important;} */
  .gist-file
  .gist-data {max-height: 300px;max-width: 1000px;}
</style>

<script src="https://gist.github.com/blinkybool/1390d53a730493e2ce72549c5bf7eaec.js?file=Stream.luau"></script>

<p>This is (part 1 of) a conceptual intro to <code class="language-plaintext highlighter-rouge">Stream.luau</code>, a (very new) library I wrote for managing the complexity of event-driven programming in Roblox (with types!).
It is directly inspired by <a href="https://quenty.github.io/NevermoreEngine/api/Rx/">Rx (Nevermore)</a>, which itself is a port of <a href="https://rxjs.dev/">RxJS</a> to lua (also see the <a href="https://gist.github.com/Anaminus/1f31af4e5280b9333f3f58e13840c670">standalone version by Anaminus</a>). See the “IAQ” (immediately anticipated questions) section at the end for comparisons to observables and Rx. For now we will not assume prior familiarity with observables.</p>

<h2 id="what-is-a-stream">What is a Stream?</h2>
<p>It’s a function (there are no classes in this library - just typed-functions), which takes a <code class="language-plaintext highlighter-rouge">listener: (T...) -&gt; ()</code> (a function that can be fed arguments of the appropriate type) and returns a CleanupTask. A CleanupTask is usually something like an <code class="language-plaintext highlighter-rouge">RBXScriptConnection</code>, and cleaning it means to disconnect it.</p>
<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">export</span> <span class="nb">type</span> <span class="n">CleanupTask</span> <span class="o">=</span> <span class="c1">-- omitted</span>
<span class="n">export</span> <span class="nb">type</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">T</span><span class="o">...&gt;</span> <span class="o">=</span> <span class="p">(</span><span class="n">listener</span><span class="p">:</span> <span class="p">(</span><span class="n">T</span><span class="o">...</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">())</span> <span class="o">-&gt;</span> <span class="n">CleanupTask</span>
<span class="c1">-- example: `Stream&lt;number,string&gt;` is the type `(listener: (number, string) -&gt; ()) -&gt; CleanupTask`</span>
</code></pre></div></div>
<p>When a <code class="language-plaintext highlighter-rouge">stream : Stream&lt;number&gt;</code> is called with a <code class="language-plaintext highlighter-rouge">listener</code>, it can call <code class="language-plaintext highlighter-rouge">listener(x)</code> with any number <code class="language-plaintext highlighter-rouge">x</code> whenever it likes (synchronously or asynchronously), but it must cancel all future calls once it’s <code class="language-plaintext highlighter-rouge">CleanupTask</code> is “cleaned”.
Here is a toy-example to illustrate (we use the terminology “emits <code class="language-plaintext highlighter-rouge">x</code>” when the stream calls the listener with <code class="language-plaintext highlighter-rouge">x</code>).</p>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">local</span> <span class="k">function</span> <span class="nf">myStream</span><span class="p">(</span><span class="n">listener</span><span class="p">:</span> <span class="p">(</span><span class="n">number</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">()):</span> <span class="n">CleanupTask</span>
	<span class="c1">-- Emits synchronously</span>
	<span class="n">listener</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="n">listener</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

	<span class="c1">-- Emits asynchronously</span>
	<span class="kd">local</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">3</span>
	<span class="kd">local</span> <span class="n">thread</span> <span class="o">=</span> <span class="n">task</span><span class="p">.</span><span class="n">spawn</span><span class="p">(</span><span class="k">function</span><span class="p">()</span>
		<span class="k">while</span> <span class="kc">true</span> <span class="k">do</span>
			<span class="n">task</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">listener</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
			<span class="n">value</span> <span class="o">+=</span> <span class="mi">1</span>
		<span class="k">end</span>
	<span class="k">end</span><span class="p">)</span>

	<span class="c1">-- This is the cleanup - `clean(thread)` will stop this stream.</span>
	<span class="k">return</span> <span class="n">thread</span>
<span class="k">end</span>

<span class="kd">local</span> <span class="n">cleanup</span> <span class="o">=</span> <span class="n">myStream</span><span class="p">(</span><span class="nb">print</span><span class="p">)</span> <span class="c1">-- prints 1 and 2 immediately</span>
<span class="c1">-- will print 3,4,5,6... every second until cleanup is called</span>
<span class="n">task</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="mi">4</span><span class="p">.</span><span class="mi">5</span><span class="p">)</span>
<span class="n">clean</span><span class="p">(</span><span class="n">cleanup</span><span class="p">)</span>
</code></pre></div></div>

<p>Streams are about control-flow and data-flow. By listening to a stream, i.e. giving it a callback/behaviour, you yield control to the stream to decide when and with-what-data that behaviour is executed. In this sense, they can be thought of as a common generalisation of for-loops and events, which both provide data from some source, and execute a behaviour synchronously (for-loops) or asynchronously (events).</p>

<p>But do not be mistaken, they are strictly more powerful than either concept!</p>

<p>The reason is that setting up control-flow (connecting to events/streams), while managing the timely clean up of all connections, can explode in complexity. You will do one of the following:</p>
<ol>
  <li>Grit your teeth and pollute your code with layers of housekeeping logic</li>
  <li>Half-grit your teeth and implement the correct control flow, but with memory leaks (not disconnecting connections)</li>
  <li>Fail to implement the control flow correctly (slack-jawed?)</li>
</ol>

<p>The first cause of complexity, which we will explore in this post, is the need to connect to a dynamically-defined event (Spoiler: it is solved by <code class="language-plaintext highlighter-rouge">switchMap</code>!).</p>

<h2 id="dynamically-defined-events">Dynamically defined events</h2>

<p>Suppose the local player’s character-model has a “Damage” attribute which we want to display on the screen.
A first approximation might look like:</p>
<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">local</span> <span class="k">function</span> <span class="nf">updateDamageGui</span><span class="p">(</span><span class="n">damage</span><span class="p">:</span> <span class="n">number</span><span class="err">?</span><span class="p">)</span>
	<span class="c1">-- do stuff</span>
	<span class="c1">-- ...</span>
	<span class="c1">-- ...</span>
<span class="k">end</span>

<span class="n">updateDamageGui</span><span class="p">(</span><span class="n">Players</span><span class="p">.</span><span class="n">LocalPlayer</span><span class="p">.</span><span class="n">Character</span><span class="p">:</span><span class="n">GetAttribute</span><span class="p">(</span><span class="s2">"Damage"</span><span class="p">))</span>
<span class="kd">local</span> <span class="n">connection</span> <span class="o">=</span> <span class="n">Players</span><span class="p">.</span><span class="n">LocalPlayer</span><span class="p">.</span><span class="n">Character</span><span class="p">:</span><span class="n">GetAttributeChangedSignal</span><span class="p">(</span><span class="s2">"Damage"</span><span class="p">):</span><span class="n">Connect</span><span class="p">(</span><span class="k">function</span><span class="p">()</span>
	<span class="n">updateDamageGui</span><span class="p">(</span><span class="n">Players</span><span class="p">.</span><span class="n">LocalPlayer</span><span class="p">.</span><span class="n">Character</span><span class="p">:</span><span class="n">GetAttribute</span><span class="p">(</span><span class="s2">"Damage"</span><span class="p">))</span>
<span class="k">end</span><span class="p">)</span>
<span class="c1">-- disconnect the connection when done displaying</span>
</code></pre></div></div>
<p>If only it was that simple!
Problems:</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">Players.LocalPlayer.Character</code> might be nil (and will be on startup), and therefore we do not have static access to the “PropertyChanged” event - it is dependent on the character instance, so it is a <em>dynamically defined event</em>.</li>
  <li>The call to <code class="language-plaintext highlighter-rouge">updateDamageGui</code> has been duplicated, hence the abstraction into a function.
Problem 2 is not so-bad here, but, as we’ll see, can worsen arbitrarily when behaviour is scattered amongst a mess of housekeeping logic.</li>
</ol>

<p>Problem 1 is terrible. Let’s chuck a <code class="language-plaintext highlighter-rouge">:Wait()</code> on it!</p>
<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">local</span> <span class="n">character</span> <span class="o">=</span> <span class="n">Players</span><span class="p">.</span><span class="n">LocalPlayer</span><span class="p">.</span><span class="n">Character</span> <span class="ow">or</span> <span class="n">Players</span><span class="p">.</span><span class="n">LocalPlayer</span><span class="p">.</span><span class="n">CharacterAdded</span><span class="p">:</span><span class="n">Wait</span><span class="p">()</span>
<span class="n">updateDamageGui</span><span class="p">(</span><span class="n">character</span><span class="p">:</span><span class="n">GetAttribute</span><span class="p">(</span><span class="s2">"Damage"</span><span class="p">))</span>
<span class="kd">local</span> <span class="n">connection</span> <span class="o">=</span> <span class="n">character</span><span class="p">:</span><span class="n">GetAttributeChangedSignal</span><span class="p">(</span><span class="s2">"Damage"</span><span class="p">):</span><span class="n">Connect</span><span class="p">(</span><span class="k">function</span><span class="p">()</span>
	<span class="n">updateDamageGui</span><span class="p">(</span><span class="n">character</span><span class="p">:</span><span class="n">GetAttribute</span><span class="p">(</span><span class="s2">"Damage"</span><span class="p">))</span>
<span class="k">end</span><span class="p">)</span>
</code></pre></div></div>

<p>Oh no, our damage stops updating after our character respawns, because <code class="language-plaintext highlighter-rouge">Players.LocalPlayer.Character</code> is a different instance now!
Let’s jump ahead to a fully-correct implementation. Grit your teeth!</p>
<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">local</span> <span class="n">attributeConnection</span> <span class="o">=</span> <span class="kc">nil</span>
<span class="kd">local</span> <span class="k">function</span> <span class="nf">handleCharacter</span><span class="p">(</span><span class="n">character</span><span class="p">:</span> <span class="n">Model</span><span class="err">?</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">character</span> <span class="o">==</span> <span class="kc">nil</span> <span class="k">then</span>
		<span class="n">updateDamageGui</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="k">end</span>
	<span class="n">updateDamageGui</span><span class="p">(</span><span class="n">character</span><span class="p">:</span><span class="n">GetAttribute</span><span class="p">(</span><span class="s2">"Damage"</span><span class="p">))</span>
	<span class="k">if</span> <span class="n">attributeConnection</span> <span class="o">~=</span> <span class="kc">nil</span> <span class="k">then</span>
		<span class="n">attributeConnection</span><span class="p">:</span><span class="n">Disconnect</span><span class="p">()</span>
	<span class="k">end</span>
	<span class="n">attributeConnection</span> <span class="o">=</span> <span class="n">character</span><span class="p">:</span><span class="n">GetAttributeChangedSignal</span><span class="p">(</span><span class="s2">"Damage"</span><span class="p">):</span><span class="n">Connect</span><span class="p">(</span><span class="k">function</span><span class="p">()</span>
		<span class="n">updateDamageGui</span><span class="p">(</span><span class="n">character</span><span class="p">:</span><span class="n">GetAttribute</span><span class="p">(</span><span class="s2">"Damage"</span><span class="p">))</span>
	<span class="k">end</span><span class="p">)</span>
<span class="k">end</span>
<span class="n">handleCharacter</span><span class="p">(</span><span class="n">Players</span><span class="p">.</span><span class="n">LocalPlayer</span><span class="p">.</span><span class="n">Character</span><span class="p">)</span>
<span class="kd">local</span> <span class="n">characterConnection</span> <span class="o">=</span> <span class="n">Players</span><span class="p">.</span><span class="n">LocalPlayer</span><span class="p">:</span><span class="n">GetPropertyChangedSignal</span><span class="p">(</span><span class="s2">"Character"</span><span class="p">):</span><span class="n">Connect</span><span class="p">(</span><span class="k">function</span><span class="p">()</span>
	<span class="n">handleCharacter</span><span class="p">(</span><span class="n">Players</span><span class="p">.</span><span class="n">LocalPlayer</span><span class="p">.</span><span class="n">Character</span><span class="p">)</span>
<span class="k">end</span><span class="p">)</span>
<span class="c1">-- Disconnect attributeConnection (if not nil!) and characterConnection when done displaying</span>
</code></pre></div></div>
<p>🤮
Problems:</p>
<ol>
  <li>This is a mess: our important behaviour is getting harder to locate</li>
  <li>We are polluting our local variables with housekeeping variables, which are obtaining more complex names to distinguish themselves.</li>
  <li>When we are done with this behaviour, we have to disconnect our connections in a specific way (<code class="language-plaintext highlighter-rouge">attributeConnection</code> if it’s not nil and then <code class="language-plaintext highlighter-rouge">characterConnection</code>). If the nature of the behaviour changes, we must maintain the cleanup logic accordingly, which likely exists in another location.</li>
</ol>

<p>Let’s start by separating the behaviour from the housekeeping, and encapsulate the cleanup logic.</p>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">local</span> <span class="k">function</span> <span class="nf">onDamageAttribute</span><span class="p">(</span><span class="n">callback</span><span class="p">:</span> <span class="p">(</span><span class="n">number</span><span class="err">?</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">()):</span> <span class="n">CleanupTask</span>
	<span class="c1">-- We have replaced `updateDamageGui` with `callback`.</span>
	<span class="kd">local</span> <span class="n">attributeConnection</span> <span class="o">=</span> <span class="kc">nil</span>
	<span class="kd">local</span> <span class="k">function</span> <span class="nf">handleCharacter</span><span class="p">(</span><span class="n">character</span><span class="p">:</span> <span class="n">Model</span><span class="err">?</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">character</span> <span class="o">==</span> <span class="kc">nil</span> <span class="k">then</span>
			<span class="n">callback</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="k">end</span>
		<span class="n">callback</span><span class="p">(</span><span class="n">character</span><span class="p">:</span><span class="n">GetAttribute</span><span class="p">(</span><span class="s2">"Damage"</span><span class="p">))</span>
		<span class="k">if</span> <span class="n">attributeConnection</span> <span class="o">~=</span> <span class="kc">nil</span> <span class="k">then</span>
			<span class="n">attributeConnection</span><span class="p">:</span><span class="n">Disconnect</span><span class="p">()</span>
		<span class="k">end</span>
		<span class="n">attributeConnection</span> <span class="o">=</span> <span class="n">character</span><span class="p">:</span><span class="n">GetAttributeChangedSignal</span><span class="p">(</span><span class="s2">"Damage"</span><span class="p">):</span><span class="n">Connect</span><span class="p">(</span><span class="k">function</span><span class="p">()</span>
			<span class="n">callback</span><span class="p">(</span><span class="n">character</span><span class="p">:</span><span class="n">GetAttribute</span><span class="p">(</span><span class="s2">"Damage"</span><span class="p">))</span>
		<span class="k">end</span><span class="p">)</span>
	<span class="k">end</span>
	<span class="n">handleCharacter</span><span class="p">(</span><span class="n">Players</span><span class="p">.</span><span class="n">LocalPlayer</span><span class="p">.</span><span class="n">Character</span><span class="p">)</span>
	<span class="kd">local</span> <span class="n">characterConnection</span> <span class="o">=</span> <span class="n">Players</span><span class="p">.</span><span class="n">LocalPlayer</span><span class="p">:</span><span class="n">GetPropertyChangedSignal</span><span class="p">(</span><span class="s2">"Character"</span><span class="p">):</span><span class="n">Connect</span><span class="p">(</span><span class="k">function</span><span class="p">()</span>
		<span class="n">handleCharacter</span><span class="p">(</span><span class="n">Players</span><span class="p">.</span><span class="n">LocalPlayer</span><span class="p">.</span><span class="n">Character</span><span class="p">)</span>
	<span class="k">end</span><span class="p">)</span>
	
	<span class="c1">-- Wrapped cleanup logic (made idempotent)</span>
	<span class="kd">local</span> <span class="n">cleanup</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
		<span class="k">if</span> <span class="n">attributeConnection</span> <span class="o">~=</span> <span class="kc">nil</span> <span class="k">then</span>
			<span class="n">attributeConnection</span><span class="p">:</span><span class="n">Disconnect</span><span class="p">()</span>
			<span class="n">attributeConnection</span> <span class="o">=</span> <span class="kc">nil</span>
		<span class="k">end</span>
		<span class="k">if</span> <span class="n">characterConnection</span> <span class="o">~=</span> <span class="kc">nil</span> <span class="k">then</span>
			<span class="n">characterConnection</span><span class="p">:</span><span class="n">Disconnect</span><span class="p">()</span>
			<span class="n">characterConnection</span> <span class="o">=</span> <span class="kc">nil</span>
		<span class="k">end</span>
	<span class="k">end</span>

	<span class="k">return</span> <span class="n">cleanup</span>
<span class="k">end</span>

<span class="kd">local</span> <span class="n">cleanup</span> <span class="o">=</span> <span class="n">onDamageAttribute</span><span class="p">(</span><span class="n">updateDamageGui</span><span class="p">)</span>
<span class="c1">-- call `clean(cleanup)` when done displaying</span>
</code></pre></div></div>
<p>🤔
We have separated our housekeeping logic from our behaviour, and encapsulated the cleanup logic.
Hiding/moving complexity is not virtuous in itself, but we will find that we can
decompose <code class="language-plaintext highlighter-rouge">onDamageAttribute</code> into <em>reusable</em> and <em>composable</em> parts, which clearly express the
intended behaviour.</p>

<p>From here on, we start using stream terminology. We see <code class="language-plaintext highlighter-rouge">onDamageAttribute</code> has type <code class="language-plaintext highlighter-rouge">Stream&lt;number?&gt; = ((number?) -&gt; ()) -&gt; CleanupTask</code>, so we’ll call it <code class="language-plaintext highlighter-rouge">damageStream</code>, and instead of <code class="language-plaintext highlighter-rouge">callback</code>, we opt for the term <code class="language-plaintext highlighter-rouge">listener</code>.</p>

<p>Here is the full decomposition of <code class="language-plaintext highlighter-rouge">onDamageAttribute</code>, with nothing omitted (except <code class="language-plaintext highlighter-rouge">clean</code>).</p>
<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">local</span> <span class="n">characterStream</span><span class="p">:</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">Model</span><span class="err">?</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">function</span><span class="p">(</span><span class="n">listener</span><span class="p">:</span> <span class="p">(</span><span class="n">Model</span><span class="err">?</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">())</span>
	<span class="n">listener</span><span class="p">(</span><span class="n">Players</span><span class="p">.</span><span class="n">LocalPlayer</span><span class="p">.</span><span class="n">Character</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">Players</span><span class="p">.</span><span class="n">LocalPlayer</span><span class="p">:</span><span class="n">GetPropertyChangedSignal</span><span class="p">(</span><span class="s2">"Character"</span><span class="p">):</span><span class="n">Connect</span><span class="p">(</span><span class="k">function</span><span class="p">()</span>
		<span class="n">listener</span><span class="p">(</span><span class="n">Players</span><span class="p">.</span><span class="n">LocalPlayer</span><span class="p">.</span><span class="n">Character</span><span class="p">)</span>
	<span class="k">end</span><span class="p">)</span>
<span class="k">end</span>

<span class="c1">-- Make a stream which emits an Attribute of an instance (immediately and on-change)</span>
<span class="kd">local</span> <span class="k">function</span> <span class="nf">attributeOf</span><span class="p">(</span><span class="n">instance</span><span class="p">:</span> <span class="n">Instance</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">string</span><span class="p">):</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">any</span><span class="err">?</span><span class="o">&gt;</span>
	<span class="k">return</span> <span class="k">function</span><span class="p">(</span><span class="n">listener</span><span class="p">:</span> <span class="p">(</span><span class="n">any</span><span class="err">?</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">())</span>
		<span class="n">listener</span><span class="p">(</span><span class="n">instance</span><span class="p">:</span><span class="n">GetAttribute</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">instance</span><span class="p">:</span><span class="n">GetAttributeChangedSignal</span><span class="p">(</span><span class="n">name</span><span class="p">):</span><span class="n">Connect</span><span class="p">(</span><span class="k">function</span><span class="p">()</span>
			<span class="n">listener</span><span class="p">(</span><span class="n">instance</span><span class="p">:</span><span class="n">GetAttribute</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
		<span class="k">end</span><span class="p">)</span>
	<span class="k">end</span>
<span class="k">end</span>

<span class="c1">-- A Stream&lt;T?&gt; which just emits nil once (immediately)</span>
<span class="kd">local</span> <span class="k">function</span> <span class="nf">nilOnce</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">listener</span><span class="p">:</span> <span class="p">(</span><span class="n">T</span><span class="err">?</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">()):</span> <span class="n">CleanupTask</span>
	<span class="n">listener</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="k">end</span>

<span class="kd">local</span> <span class="n">damageStreamStream</span><span class="p">:</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">Stream</span><span class="o">&lt;</span><span class="n">number</span><span class="err">?</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="k">function</span><span class="p">(</span><span class="n">listener</span><span class="p">:</span> <span class="p">(</span><span class="n">Stream</span><span class="o">&lt;</span><span class="n">number</span><span class="err">?</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">()):</span> <span class="n">CleanUpTask</span>
	<span class="c1">-- The return here returns the CleanUpTask of the character stream</span>
	<span class="c1">-- (in this case, a :GetPropertyChangedSignal("Character") connection)</span>
	<span class="k">return</span> <span class="n">characterStream</span><span class="p">(</span><span class="k">function</span><span class="p">(</span><span class="n">character</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">character</span> <span class="k">then</span>
			<span class="kd">local</span> <span class="n">innerStream</span> <span class="o">=</span> <span class="n">attributeOf</span><span class="p">(</span><span class="n">character</span><span class="p">,</span> <span class="s2">"Damage"</span><span class="p">)</span>
			<span class="n">listener</span><span class="p">(</span><span class="n">innerStream</span><span class="p">)</span>
		<span class="k">else</span>
			<span class="n">listener</span><span class="p">(</span><span class="n">nilOnce</span><span class="p">)</span>
		<span class="k">end</span>
	<span class="k">end</span><span class="p">)</span>
<span class="k">end</span>

<span class="c1">-- (this logic is just what switchAll does)</span>
<span class="c1">-- Note that `cleanupInner`, `cleanupStream` will be what we previously called `attributeConnection` and `characterConnection`</span>
<span class="kd">local</span> <span class="n">damageStream</span><span class="p">:</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">number</span><span class="err">?</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">function</span><span class="p">(</span><span class="n">listener</span><span class="p">:</span> <span class="p">(</span><span class="n">number</span><span class="err">?</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">())</span>
	<span class="kd">local</span> <span class="n">cleanupInner</span> <span class="o">=</span> <span class="kc">nil</span>
	<span class="kd">local</span> <span class="n">cleanupStream</span> <span class="o">=</span> <span class="n">damageStreamStream</span><span class="p">(</span><span class="k">function</span><span class="p">(</span><span class="n">innerStream</span><span class="p">:</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">number</span><span class="err">?</span><span class="o">&gt;</span><span class="p">):</span> <span class="p">()</span>
		<span class="n">clean</span><span class="p">(</span><span class="n">cleanupInner</span><span class="p">)</span>
		<span class="n">cleanupInner</span> <span class="o">=</span> <span class="kc">nil</span>
		<span class="n">cleanupInner</span> <span class="o">=</span> <span class="n">innerStream</span><span class="p">(</span><span class="n">listener</span><span class="p">)</span>
	<span class="k">end</span><span class="p">)</span>
	<span class="k">return</span> <span class="k">function</span><span class="p">()</span>
		<span class="n">clean</span><span class="p">(</span><span class="n">cleanupInner</span><span class="p">)</span>
		<span class="n">cleanupInner</span> <span class="o">=</span> <span class="kc">nil</span>
		<span class="n">clean</span><span class="p">(</span><span class="n">cleanupStream</span><span class="p">)</span>
		<span class="n">cleanupStream</span> <span class="o">=</span> <span class="kc">nil</span>
	<span class="k">end</span>
<span class="k">end</span>

<span class="kd">local</span> <span class="n">cleanup</span> <span class="o">=</span> <span class="n">damageStream</span><span class="p">(</span><span class="n">updateDamageGui</span><span class="p">)</span>
<span class="c1">-- call `clean(cleanup)`</span>
</code></pre></div></div>

<p>Now we have some simple components here that we can extract into reusable library functions, such as <code class="language-plaintext highlighter-rouge">attributeOf</code> and <code class="language-plaintext highlighter-rouge">propertyOf</code> (a generalisation of <code class="language-plaintext highlighter-rouge">characterStream</code>). What is the best way to decompose/understand the creation of <code class="language-plaintext highlighter-rouge">damageStream</code> from <code class="language-plaintext highlighter-rouge">characterStream</code> via <code class="language-plaintext highlighter-rouge">damageStreamStream</code>?</p>

<p>The answer is <code class="language-plaintext highlighter-rouge">switchMap(fn)(characterStream)</code>, where <code class="language-plaintext highlighter-rouge">fn</code> maps characters to damage streams (or <code class="language-plaintext highlighter-rouge">nilOnce</code>). Internally, <code class="language-plaintext highlighter-rouge">switchMap</code> maps the emitted characters to damage streams, and uses <code class="language-plaintext highlighter-rouge">switchAll</code> to emit from the latest damage stream.</p>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">local</span> <span class="k">function</span> <span class="nf">switchAll</span><span class="o">&lt;</span><span class="n">T</span><span class="o">...&gt;</span><span class="p">(</span><span class="n">stream</span><span class="p">:</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">Stream</span><span class="o">&lt;</span><span class="n">T</span><span class="o">...&gt;&gt;</span><span class="p">):</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">T</span><span class="o">...&gt;</span>
	<span class="k">return</span> <span class="k">function</span><span class="p">(</span><span class="n">listener</span><span class="p">:</span> <span class="p">(</span><span class="n">T</span><span class="o">...</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">()):</span> <span class="n">CleanupTask</span>
		<span class="kd">local</span> <span class="n">cleanupInner</span> <span class="o">=</span> <span class="kc">nil</span>
		<span class="kd">local</span> <span class="n">cleanupStream</span> <span class="o">=</span> <span class="n">stream</span><span class="p">(</span><span class="k">function</span><span class="p">(</span><span class="n">innerStream</span><span class="p">:</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">T</span><span class="o">...&gt;</span><span class="p">):</span> <span class="p">()</span>
			<span class="n">clean</span><span class="p">(</span><span class="n">cleanupInner</span><span class="p">)</span>
			<span class="n">cleanupInner</span> <span class="o">=</span> <span class="kc">nil</span>
			<span class="n">cleanupInner</span> <span class="o">=</span> <span class="n">innerStream</span><span class="p">(</span><span class="n">listener</span><span class="p">)</span>
		<span class="k">end</span><span class="p">)</span>
		<span class="k">return</span> <span class="k">function</span><span class="p">()</span>
			<span class="n">clean</span><span class="p">(</span><span class="n">cleanupInner</span><span class="p">)</span>
			<span class="n">cleanupInner</span> <span class="o">=</span> <span class="kc">nil</span>
			<span class="n">clean</span><span class="p">(</span><span class="n">cleanupStream</span><span class="p">)</span>
			<span class="n">cleanupStream</span> <span class="o">=</span> <span class="kc">nil</span>
		<span class="k">end</span>
	<span class="k">end</span>
<span class="k">end</span>

<span class="kd">local</span> <span class="k">function</span> <span class="nf">switchMap</span><span class="o">&lt;</span><span class="n">T</span><span class="o">...</span><span class="p">,</span><span class="n">U</span><span class="o">...&gt;</span><span class="p">(</span><span class="n">fn</span><span class="p">:</span> <span class="p">(</span><span class="n">T</span><span class="o">...</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">U</span><span class="o">...&gt;</span><span class="p">):</span> <span class="p">(</span><span class="n">Stream</span><span class="o">&lt;</span><span class="n">T</span><span class="o">...&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">U</span><span class="o">...&gt;</span>
	<span class="k">return</span> <span class="k">function</span><span class="p">(</span><span class="n">source</span><span class="p">:</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">T</span><span class="o">...&gt;</span><span class="p">):</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">U</span><span class="o">...&gt;</span>
		<span class="k">return</span> <span class="n">switchAll</span><span class="p">(</span><span class="k">function</span><span class="p">(</span><span class="n">streamListener</span><span class="p">:</span> <span class="p">(</span><span class="n">Stream</span><span class="o">&lt;</span><span class="n">U</span><span class="o">...&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">()):</span> <span class="n">CleanupTask</span>
			<span class="c1">-- Apply fn to every emitted value to get a stream, and give it to the streamListener</span>
			<span class="k">return</span> <span class="n">source</span><span class="p">(</span><span class="k">function</span><span class="p">(</span><span class="o">...</span><span class="p">:</span> <span class="n">T</span><span class="o">...</span><span class="p">):</span> <span class="p">()</span>
				<span class="n">streamListener</span><span class="p">(</span><span class="n">fn</span><span class="p">(</span><span class="o">...</span><span class="p">))</span>
			<span class="k">end</span><span class="p">)</span>
		<span class="k">end</span><span class="p">)</span>
	<span class="k">end</span>
<span class="k">end</span>

<span class="kd">local</span> <span class="n">characterStream</span><span class="p">:</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">Model</span><span class="err">?</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">propertyOf</span><span class="p">(</span><span class="n">Players</span><span class="p">.</span><span class="n">LocalPlayer</span><span class="p">,</span> <span class="s2">"Character"</span><span class="p">)</span>
<span class="kd">local</span> <span class="k">function</span> <span class="nf">characterToDamageStream</span><span class="p">(</span><span class="n">character</span><span class="p">:</span> <span class="n">Model</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">character</span> <span class="k">then</span>
		<span class="k">return</span> <span class="n">attributeOf</span><span class="p">(</span><span class="n">character</span><span class="p">,</span> <span class="s2">"Damage"</span><span class="p">)</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">nilOnce</span>
	<span class="k">end</span>
<span class="k">end</span>
<span class="kd">local</span> <span class="n">damageStream</span><span class="p">:</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">number</span><span class="err">?</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">switchMap</span><span class="p">(</span><span class="n">characterToDamageStream</span><span class="p">)(</span><span class="n">characterStream</span><span class="p">)</span>
</code></pre></div></div>

<p>This kind of combination of <code class="language-plaintext highlighter-rouge">switchMap</code> with <code class="language-plaintext highlighter-rouge">attributeOf</code> or <code class="language-plaintext highlighter-rouge">propertyOf</code> is common enough that we provide a shorthand <code class="language-plaintext highlighter-rouge">toAttribute(name): (Stream&lt;Instance?&gt;) -&gt; Stream&lt;any?&gt;</code> (resp. <code class="language-plaintext highlighter-rouge">toProperty</code>) for it, which allows a terse/idiomatic presentation.</p>
<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">local</span> <span class="n">damageStream</span> <span class="o">=</span> <span class="n">pipe1</span><span class="p">(</span>
	<span class="n">propertyOf</span><span class="p">(</span><span class="n">Players</span><span class="p">.</span><span class="n">LocalPlayer</span><span class="p">,</span> <span class="s2">"Character"</span><span class="p">),</span>
	<span class="n">toAttribute</span><span class="p">(</span><span class="s2">"Damage"</span><span class="p">)</span>
<span class="p">)</span>
<span class="kd">local</span> <span class="n">cleanup</span> <span class="o">=</span> <span class="n">listen</span><span class="p">(</span><span class="n">damageStream</span><span class="p">,</span> <span class="n">updateDamageGui</span><span class="p">)</span>
</code></pre></div></div>
<p>Some notes:</p>
<ul>
  <li>This definition of <code class="language-plaintext highlighter-rouge">damageStream</code> evaluates to <code class="language-plaintext highlighter-rouge">toAttribute("Damage")(propertyOf(Players.LocalPlayer, "Character"))</code>. Piping is just a way to reverse application syntax, so that stream-transformers are sequenced after the stream.</li>
  <li><code class="language-plaintext highlighter-rouge">listen</code> is again just syntax, it just does <code class="language-plaintext highlighter-rouge">damageStream(updateDamageGui)</code> - don’t use it if you don’t like it</li>
  <li>Since <code class="language-plaintext highlighter-rouge">updateDamageGui</code> is no longer duplicated, we can simply write it’s contents within the listen call, like this:
    <div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">local</span> <span class="n">cleanup</span> <span class="o">=</span> <span class="n">listen</span><span class="p">(</span><span class="n">damageStream</span><span class="p">,</span> <span class="k">function</span><span class="p">(</span><span class="n">damage</span><span class="p">:</span> <span class="n">number</span><span class="err">?</span><span class="p">)</span>
  <span class="c1">-- do stuff</span>
  <span class="c1">-- ...</span>
  <span class="c1">-- ...</span>
<span class="k">end</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>Okay, what if our requirements evolve, and instead, we have an <code class="language-plaintext highlighter-rouge">ObjectValue</code> pointing at a <code class="language-plaintext highlighter-rouge">Player?</code>, and we want to display their damage? Here’s how it might look using the functions in this library.</p>
<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">local</span> <span class="n">selectedPlayer</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="s2">"ObjectValue"</span><span class="p">)</span>
<span class="kd">local</span> <span class="n">damageStream</span> <span class="o">=</span> <span class="n">pipe2</span><span class="p">(</span>
	<span class="n">fromValueBase</span><span class="p">(</span><span class="n">selectedPlayer</span><span class="p">),</span>
	<span class="n">toProperty</span><span class="p">(</span><span class="s2">"Character"</span><span class="p">),</span>
	<span class="n">toAttribute</span><span class="p">(</span><span class="s2">"Damage"</span><span class="p">)</span>
<span class="p">)</span>
<span class="kd">local</span> <span class="n">cleanup</span> <span class="o">=</span> <span class="n">listen</span><span class="p">(</span><span class="n">damageStream</span><span class="p">,</span> <span class="n">updateDamageGui</span><span class="p">)</span>
</code></pre></div></div>
<p>Imagine writing all of the housekeeping logic for this in the first style!</p>

<h2 id="reflection">Reflection</h2>

<p>In reflection: is this good programming?</p>

<p>The real test is whether working with these abstractions in practice is easier in the long run than working with the original mess.</p>
<ul>
  <li>Is it flexible and maintainable?</li>
  <li>Is it easy to understand and debug?</li>
  <li>How much overhead does it add - both cognitively and computationally?</li>
</ul>

<p>I have written <code class="language-plaintext highlighter-rouge">Stream.luau</code> with these things in mind. In particular, streams are just functions, and their internal state is entirely implemented through local variables in their closure. In many cases, it is straightforward to take an abstractly presented stream, such as our <code class="language-plaintext highlighter-rouge">damageStream</code> example, and repeatedly beta-reduce (for every function <code class="language-plaintext highlighter-rouge">f(x)</code>, and expression <code class="language-plaintext highlighter-rouge">exp</code>, replace <code class="language-plaintext highlighter-rouge">f(exp)</code> with the body of <code class="language-plaintext highlighter-rouge">f</code> with <code class="language-plaintext highlighter-rouge">x</code> replaced by <code class="language-plaintext highlighter-rouge">exp</code>) until the code resembles the original barebones implementation (with <code class="language-plaintext highlighter-rouge">attributeConnection</code> and <code class="language-plaintext highlighter-rouge">characterConnection</code>). This is basically reversing the process of abstraction that we followed - and this thought process is useful for keeping your feet on the ground about what you are doing.</p>

<p>I deliberately avoid using abstractions like maids, signals, brios inside this library - because the cleanup logic is not that difficult to write manually! We are writing a library to do housekeeping for the user, we do not need housekeeping help ourselves. I have also done this to try make stepping-through-the-code-debugging a less miserable experience - it’s easier if we’re not venturing into the guts of a maid every other line.</p>

<p>This library of functions is not an API. I am not doing any complex optimisations under the hood to make up for abstraction overhead. Instead, I’ve tried to walk the road of non-pessimism and wrote the dead-simplest code I could to implement the behaviour. I recommend just reading all of the code and changing whatever design decisions you disagree with.</p>

<p>From my experience with Rx, I don’t think this goes without saying: don’t use streams as a universal hammer for every problem, and try not to get too big-brained about fancy ways of combining streams together. It is possible to do some very complicated stream-piping karate to construct the perfect stream to feed into a short listener function, where in-fact you could have just moved more code into your listener function for a more readable result, or just split your problem into two streams. Sometimes the most readable stream is one you define from scratch (it’s just a function!) - you don’t need to build every stream out of stream primitives and transformers. Conversely, you <em>should</em> use the library functions when they do some real, non-trivial work for you, like <code class="language-plaintext highlighter-rouge">switchMap</code> and <code class="language-plaintext highlighter-rouge">combineLatest</code> (or it’s typed interfaces: <code class="language-plaintext highlighter-rouge">combine1</code>, <code class="language-plaintext highlighter-rouge">compute2</code> etc).</p>

<p>We’ve only discussed dynamically defined events, and their solution <code class="language-plaintext highlighter-rouge">switchMap</code>.
Next time we’ll talk about managing lifetimes with <code class="language-plaintext highlighter-rouge">listenTidyEach</code> in the simplest possible way.</p>

<p>Future posts:</p>
<ul>
  <li>Lifetimes (<code class="language-plaintext highlighter-rouge">listenTidyEach</code>, <code class="language-plaintext highlighter-rouge">eachPlayer</code>, <code class="language-plaintext highlighter-rouge">eachChildOf</code>, …)</li>
  <li><code class="language-plaintext highlighter-rouge">combineLatest</code> (state management)</li>
  <li><code class="language-plaintext highlighter-rouge">mount</code>/<code class="language-plaintext highlighter-rouge">new</code> (the bones of a flexible, reactive UI framework in about 400 LOC)</li>
  <li>a fruitful relationship with the luau typechecker</li>
</ul>

<h2 id="iaq-immediately-anticipated-questions">IAQ (immediately anticipated questions)</h2>
<blockquote>
  <p>Is this battle-tested?</p>
</blockquote>

<p>Nope. I’ve barely used it yet.</p>

<blockquote>
  <p>How do I install it?</p>
</blockquote>

<p>Just copy it: <a href="https://gist.github.com/blinkybool/1390d53a730493e2ce72549c5bf7eaec">Stream.luau</a></p>

<blockquote>
  <p>What’s the difference between streams and observables, and why did you write this if we already have Rx?</p>
</blockquote>

<p>In short: streams+listeners are a simplified version of observables+subscribers, where <code class="language-plaintext highlighter-rouge">stream(listener)</code> corresponds to <code class="language-plaintext highlighter-rouge">observable:Subscribe(onFire)</code>. The <code class="language-plaintext highlighter-rouge">:Subscribe(onFire, onFail, onComplete)</code> method constructs a <code class="language-plaintext highlighter-rouge">Subscriber</code> object using the provided functions, and passes it internally to <code class="language-plaintext highlighter-rouge">observable._onSuscribe(sub)</code>. So a stream is just an <code class="language-plaintext highlighter-rouge">_onSubscribe</code> function, and a listener is just an <code class="language-plaintext highlighter-rouge">onFire</code> function.</p>

<p>This library is a (typed) distillation of the core concepts in <a href="https://quenty.github.io/NevermoreEngine/api/Rx/">Rx</a>, <a href="https://quenty.github.io/NevermoreEngine/api/Brio/">Brio</a> and <a href="https://quenty.github.io/NevermoreEngine/api/Blend/">Blend</a> that I personally have found useful for programming in Roblox, which are: connecting to dynamically defined events, binding creation+cleanup or behaviour to lifetimes, declarative instance creation, and reactive state management.</p>

<p>I concluded that I could achieve all of this without subscribers having an <code class="language-plaintext highlighter-rouge">onFail</code> and <code class="language-plaintext highlighter-rouge">onComplete</code>, which, in Rx, spend most of their time being passed around, while <code class="language-plaintext highlighter-rouge">onFire</code> is where all the interesting stuff happens. Using <code class="language-plaintext highlighter-rouge">onFail</code> and <code class="language-plaintext highlighter-rouge">onComplete</code> makes observables more comparable to promises, which you may find beneficial.</p>

<p>The removal of <code class="language-plaintext highlighter-rouge">onFail</code> and <code class="language-plaintext highlighter-rouge">onComplete</code> causes many simplifications - there is no need for a subscriber to have state, so it’s essentially just a wrapper around the <code class="language-plaintext highlighter-rouge">onFire</code> callback-function - therefore why not make it just a function? The choice to make the observable/stream object itself a function, rather than a class-object, is less essential but has the following motivations:</p>
<ul>
  <li>I originally just wanted to write a typed version of Rx, because my most frequent and annoying bugs are all type errors (usually not handling nil). Typing for OOP classes/objects in Luau is not-so-well supported - there are multiple ways to achieve it, but there are tradeoffs and complications with each. On the other-hand, typing for function inputs/outputs is dead simple and quite reliable.</li>
  <li>In most contexts I don’t like to think of streams as “objects” or “data”. Listening to a stream is closer to using a compiler macro that inserts the listener logic between the housekeeping logic. Why introduce an object for this?</li>
  <li>I would like to claim that not allocating a table for every stream (like observables/maids/brios) is an advantage for streams over observables, but I lack the proper knowledge of luau to back this up (nor have I tested it - yet).</li>
  <li>Step-through-the-code debugging is important to me, not just for fixing bugs but understanding what my code is actually doing (how much non-essential busywork is it doing?). So reducing non-fundamental operations like entering an object constructor or entering a class method just to call the real-function stored in the object, makes a big difference to that experience.</li>
</ul>

<p>A compromise, that you may not like to give up, is that streams are less inspectable at runtime - the best you can do is <code class="language-plaintext highlighter-rouge">typeof(thing) == "function"</code>, and it’s not possible to distinguish a stream from any other function. You may have a programming style that necessitates object inspection like this, in which case you could go ahead and refactor everything to use a constructor like this.</p>
<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">export</span> <span class="nb">type</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">T</span><span class="o">...&gt;</span> <span class="o">=</span> <span class="p">{</span> <span class="n">ClassName</span><span class="p">:</span> <span class="s2">"Stream"</span><span class="p">,</span> <span class="n">onListen</span><span class="p">:</span> <span class="p">((</span><span class="n">T</span><span class="o">...</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">())</span> <span class="o">-&gt;</span> <span class="n">CleanupTask</span> <span class="p">}</span> 
<span class="kd">local</span> <span class="k">function</span> <span class="nf">newStream</span><span class="o">&lt;</span><span class="n">T</span><span class="o">...&gt;</span><span class="p">(</span><span class="n">onListen</span><span class="p">:</span> <span class="p">((</span><span class="n">T</span><span class="o">...</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">())</span> <span class="o">-&gt;</span> <span class="n">CleanupTask</span><span class="p">):</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">T</span><span class="o">...&gt;</span>
	<span class="k">return</span> <span class="p">{</span> <span class="n">ClassName</span> <span class="o">=</span> <span class="s2">"Stream"</span><span class="p">,</span> <span class="n">onListen</span> <span class="o">=</span> <span class="n">onListen</span> <span class="p">}</span>
<span class="k">end</span>
<span class="c1">-- then replace every `stream(listener)` with `stream.onListen(listener)`</span>

<span class="c1">-- Alternatively (up to you to give a type for the output)</span>
<span class="kd">local</span> <span class="k">function</span> <span class="nf">newStream</span><span class="o">&lt;</span><span class="n">T</span><span class="o">...&gt;</span><span class="p">(</span><span class="n">onListen</span><span class="p">:</span> <span class="p">((</span><span class="n">T</span><span class="o">...</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">())</span> <span class="o">-&gt;</span> <span class="n">CleanupTask</span><span class="p">)</span>
	<span class="k">return</span> <span class="nb">setmetatable</span><span class="p">({</span> <span class="n">ClassName</span> <span class="o">=</span> <span class="s2">"Stream"</span> <span class="p">},</span> <span class="p">{</span> <span class="n">__call</span> <span class="o">=</span> <span class="k">function</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span> <span class="k">return</span> <span class="n">onListen</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="k">end</span><span class="p">})</span>
<span class="k">end</span>
</code></pre></div></div>
<p>For my use-cases (including <code class="language-plaintext highlighter-rouge">mount</code>), I’ve found it sufficient to just assume functions are streams.</p>

<blockquote>
  <p>Should I use this?</p>
</blockquote>

<p>If you want a third-party-maintainer to promise you a quality developer-experience and provide versioned-updates, you probably shouldn’t.
I will probably update the gist a few times in the coming weeks, and eventually integrate it into my own work, but <code class="language-plaintext highlighter-rouge">Stream.luau</code> aims to be dead-simple in implementation, so that you can debug and fix problems yourself.
You can also chop it up if you don’t like that it’s all dumped in one file, and make whatever changes you think will make it a better fit for your specific project or programming style. If there are useful transformers in <a href="https://rxmarbles.com">RxMarbles</a> or <a href="https://reactivex.io/documentation/operators.html">ReactiveX</a> you find useful, just add them (but remember there’s no fail/complete - unless you add them :P).</p>

<p>-Billy</p>

  </div>

  <a class="u-url" href="/2024/07/11/Stream-Intro.html" hidden></a>
</article>
        </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>
  <div class="wrapper">
    <div class="footer-col-wrapper">
      <div class="footer-col">
        <ul class="contact-list">
          <li class="p-name">
            <!--<a class="black-link" href="https://billysnikkers.net/about.html">
                Billy Snikkers 
              </a>-->
            </li></ul>
      </div>
    </div>
  </div>
</footer></body>
</html>
